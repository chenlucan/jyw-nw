<!DOCTYPE html>
<html>
<head>
<script src="http://cdn.pubnub.com/pubnub-3.7.12.min.js"></script>
<script src="https://www.webrtc-experiment.com/RTCPeerConnection-v1.6.js"></script>
<title>Answerer with PubSub signaling</title>

</head>

<body>
<div id='mainDiv'>
	<h2>Using email address:</h2><h1 id= "userEmail"></h1><h1 id= "connectionIndicator"></h1>
	<table border="1" width="100%">
		<tr>
			<td align="center">
				<textarea rows="4" cols="60" id="sendTextarea"></textarea>
			</td>
			<td align="center">
				<textarea rows="4" cols="60" id="receiveLog"></textarea>
			</td>		
		</tr>
		<tr>
			<td align="center">
				<button id="connectButton">Connect</button>
				<button id="sendButton">Send</button>
				<select id="typeSelect">
					<option>Notification</option>
					<option>Alert</option>
				</select>
			</td>
			<td></td>
		</tr>	
		<tr>
			<td align="center">
				<a id="received"></a>	
			</td>
			<td align="center">
			</td>
		</tr>
		<tr>
			<td align="center">
				<form id="fileInfo">
	        		<input type="file" id="fileInput" name="files" multiple/>
	        		<button id="sendFileButton">Send File</button>
				</form>
				<div class="progress">
					<div class="label">Send progress: </div>
					<progress id="sendProgress" max="0" value="0"></progress>
				</div>
			</td>
			<td></td>
		</tr>
	</table>
</div>

<script type="text/javascript">
	"use strict"
	var gui = require('nw.gui');

	var userEmail = "";
			userEmail = "lucan";
			// hard code for lucan
			// do {
			// 	userEmail = prompt("Please enter email address to connect your devices.\n\"Cancel\" to quit application");
			// } while (userEmail === "");

	if (userEmail === null || userEmail === undefined) {
		gui.App.quit();
	}
	
	var fs     = require('fs');
	var dataPath = './data/';
	fs.mkdir(dataPath, function(){});

	var userEmailText   = document.getElementById("userEmail");
	var connIndicator   = document.getElementById("connectionIndicator");
	var receiveTextarea = document.getElementById("receiveLog");
	var sendTextarea    = document.getElementById("sendTextarea");
	var receiveTextarea = document.getElementById("receiveLog");

	var connectButton   = document.getElementById("connectButton");
	var sendButton      = document.getElementById("sendButton");
	var fileInput       = document.getElementById("fileInput");
	var sendFileButton  = document.getElementById("sendFileButton");
	var sendProgress    = document.getElementById("sendProgress");

	var downloadDiv     = document.getElementById("received");

	userEmailText.innerHTML = userEmail;
	connectButton.onclick  = createOffer;
	sendButton.onclick     = sendText;
	sendFileButton.onclick = sendMultiFiles;
 
    var pubnub = PUBNUB({                          
        publish_key   : 'pub-c-540d3bfa-dd7a-4520-a9e4-907370d2ce37',
        subscribe_key : 'sub-c-3af2bc02-2b93-11e5-9bdb-0619f8945a4f'
    });
    pubnub.subscribe({                                     
        channel : userEmail,
        message : function(message,env,ch,timer,magic_ch){
        	OnPubnubMsg(message);
        },
        connect: function() {}
    });

	var offerer_role  = 'com.lucanchen.offerer';
	var answerer_role = 'com.lucanchen.answerer';

	var isDevicePC  = false;
	var selfUserID  = answerer_role;
	var otherUserID = offerer_role;
	var peer;

	// utils for file data
	var fileName = '';
	var fileSize = 0;
	var receiveBuffer = [];
	var receivedSize  = 0;
	var receiveUint8Buffer = new Uint8Array(0);

	function OnPubnubMsg(response) 
	{
	    if(response.userID == selfUserID || response.userID !== otherUserID ) {
	    	return;
	    }
	    // you can show a "join" button or you can send participant request
	    if(response.type && response.type == 'request to join') {
	    	// sendParticipant();
	    }

	    if(selfUserID == answerer_role && response.sdpType == "offer" &&
	    	(response.firstPart || response.secondPart || response.fullPart))
	    {
	        processOfferSDP(response);
	    }
	    log("================received answer 1");
	    if(selfUserID == offerer_role && response.sdpType == "answer" &&
	    	(response.firstPart || response.secondPart || response.fullPart))
	    {
	    	log("================received answer 2");
	    	log("received answer===================="+response.fullPart+"====================");
	        if (response.fullPart) {
	        	log("================received answer 3");
	        	peer.addAnswerSDP(JSON.parse(response.fullPart));
	        }
	    }
	    
	    if (response.candidate) {
	    	peer.addICE({
			    sdpMLineIndex 	: response.candidate.sdpMLineIndex,
			    sdpMid          : response.candidate.sdpMid,
			    candidate 		: response.candidate.candidate
			});
	    }
	}

	log("====================before sending participant");
	sendParticipant();
	log("====================after sending participant");

	function sendParticipant() {
		pubnub.publish({                                    
            channel : userEmail,
            message : {
			    participant: true,
			    userID: selfUserID
	    	},
            callback: function(m){}
        });
		log("sending participant");
	}

	function createOffer() {
		selfUserID  = offerer_role;
		otherUserID = answerer_role;
		log('Creating offer, so my id is changed to: offerer');
	    peer = RTCPeerConnection({
	        /* you need to pass offer sdp sent by offerer */
	        onOfferSDP: function(offerSDP) {
	        	log("received offer..............");
	        	pubnub.publish({                                    
		            channel : userEmail,
		            message : {
		                userID: selfUserID,
		                device: "pc",
		                sdpType: "offer",
		                fullPart: offerSDP
			    	},
		            callback: function(m){}
		        });
	        },
	        onICE: function(candidate) {
	        	log("sending candidate");
	            pubnub.publish({                                    
		            channel : userEmail,
		            message : {
		                userID: selfUserID,
		                candidate: {
		                    sdpMLineIndex   : candidate.sdpMLineIndex,
		                    sdpMid          : candidate.sdpMid,
		                    candidate       : candidate.candidate
		                }
			    	},
		            callback: function(m){}
		        });
	        },
	        onRemoteStream: function(stream) {
	            // if(stream) video.src = webkitURL.createObjectURL(stream);
	        },
	        onChannelMessage: function (event) {
		        decodeFileData(event.data);
	        },
    		onChannelOpened: function (channel) {
    			log("RTCDataChannel opened");
    			connIndicator.innerHTML = "Connected";
    		}, 
    		onChannelClosed: function (event) {
    			log("RTCDataChannel closed");
    			connIndicator.innerHTML = "Disconnected";
    		},
            onChannelError: function (event) {
            	log("RTCDataChannel error");
            }
	    });
	}

	function tryParseJSON (jsonString){
	    try {
	        var o = JSON.parse(jsonString);

	        // Handle non-exception-throwing cases:
	        // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
	        // but... JSON.parse(null) returns 'null', and typeof null === "object", 
	        // so we must check for that, too.
	        if (o && typeof o === "object" && o !== null) {
	            return o;
	        }
	    }
	    catch (e) { }

	    return false;
	};

	function decodeFileData(data) {
		if (isDevicePC) {
			// already knows the other peer is pc, received binary file should handle separately
			return;
		}

		var obj = tryParseJSON(data);
        if (obj) {
        	// it is json received, so data is from PC version
        	isDevicePC = true;
        	// starting from here, we assume other peer is pc

			if (obj["type"] === "File") {
				fileName = obj["fileName"];
				fileSize = obj["fileSize"];
			}
        } else {
        	var data_fileSize = new Uint32Array(data, 0, 8);
	        var data_type     = new Uint8Array(data,  8, 1);
	        var data_name     = new Uint8Array(data,  9, 19);

	        var fileSize = data_fileSize[0];
	        var type     = data_type[0];
	        var fileName = String.fromCharCode.apply(null, data_name);

	    	if (type === 0) {
	    		var fileData = data.slice(28);
				OnFileData(fileName, fileSize, fileData, data.byteLength - 28); // file hash in the future maybe
	    	} else if (type === 1) { 
	    		// type : Text
	    		log("Received text:"+data); 
	    	} else if (type === undefined) {
	    		log("Received undefined type"); 
	    	}
        }
	}

	function createAnswer(offer_sdp)
	{
		log('Creating answer');
	    peer = RTCPeerConnection({
	        /* you need to pass offer sdp sent by offerer */
	        offerSDP: offer_sdp,
	        onAnswerSDP: sendAnswerSDP,
	        onICE: function(candidate) {
	            pubnub.publish({                                    
		            channel : userEmail,
		            message : {
		                userID: selfUserID,
		                candidate: {
		                    sdpMLineIndex   : candidate.sdpMLineIndex,
		                    sdpMid          : candidate.sdpMid,
		                    candidate       : candidate.candidate
		                }
			    	},
		            callback: function(m){}
		        });
	        },
	        onRemoteStream: function(stream) {
	            // if(stream) video.src = webkitURL.createObjectURL(stream);
	        },
	        onChannelMessage: function (event) {
	        	decodeFileData(event.data);
	        },
    		onChannelOpened: function (channel) {
    			log("RTCDataChannel opened");
    			connIndicator.innerHTML = "Connected";
    		}, 
    		onChannelClosed: function (event) {
    			log("RTCDataChannel closed");
    			connIndicator.innerHTML = "Disconnected";
    		},
            onChannelError: function (event) {
            	log("RTCDataChannel error");
            }
	    });
	}

	// send answer sdp 
	function sendAnswerSDP(sdp)
	{
	    var sdp = JSON.stringify(sdp);

	    if (sdp.length <= 7000) {
			pubnub.publish({                                    
	            channel : userEmail,
	            message : {
		        	userID  : selfUserID,
		        	sdpType: "answer",
		        	fullPart: sdp
	    		},
            	callback: function(m){}
        	});

	        log("Sending answer by full part");
	    	return;
	    }

	    /* because sdp size is larger than what pubnub supports for single request...
	    /* that's why it is splitted in two parts */
	    var firstPart = sdp.substr(0, 700),
	        secondPart = sdp.substr(701, sdp.length - 1);

	    /* transmitting first sdp part */
		pubnub.publish({                                   
            channel : userEmail,
            message : {
	        	userID: selfUserID,
	        	firstPart: firstPart
	    	},
            callback: function(m){}
        });

	    /* transmitting second sdp part */
		pubnub.publish({                                    
            channel : userEmail,
            message : {
	        	userID: selfUserID,
		        secondPart: secondPart
	    	},
            callback: function(m){}
        });
	    log("Sending answer by two parts");
	}

	var offerSDP = {};

	// got offer sdp, process it, then create answer
	function processOfferSDP(response)
	{
		log("===================processOfferSDP 1");
	    if (response.firstPart) {
	    	log("===================processOfferSDP 2");
	        offerSDP.firstPart = response.firstPart;
	        if (offerSDP.secondPart) {
	            var fullSDP = offerSDP.firstPart + offerSDP.secondPart;
	            createAnswer(fullSDP);
	        }
	    }
	    log("===================processOfferSDP 3");
	    if (response.secondPart) {
	    	log("===================processOfferSDP 4");
	        offerSDP.secondPart = response.secondPart;
	        if (offerSDP.firstPart) {
	            var fullSDP = offerSDP.firstPart + offerSDP.secondPart;
	            createAnswer(fullSDP);
	        }
	    }
		log("===================processOfferSDP 5");
	    if (response.fullPart) {
	    	log("===================processOfferSDP 6");
	    	createAnswer(response.fullPart);
	    }
	}

	/////////////////////////////////////////////////////
	//Send files
	function sendMultiFiles() {
		if (fileInput.files.length == 0) {
	        log("Select one or more files.");
	    } else {
	        for (var i = 0; i < fileInput.files.length; i++) {
				log("============1===sending file "+fileInput.files[i]);
				sendFile(fileInput.files[i]);
			}
		}
		return false;
	}
	function sendFile(file) {
	  log('============2===file is ' + [file.name, file.size, file.type, file.lastModifiedDate].join(' '));
	  if (file.size === 0) {
	    return;
	  }
	  sendProgress.max = file.size;
	  // var chunkSize = 16384;
	  var chunkSize = 65000;

	  var sliceFile = function(offset) {
	  	log("============3===sending file, offset:" + offset);
	    var reader = new window.FileReader();
	    reader.onload = (function() {
	      return function(e) {
	      	if (offset === 0) {
		        var data = JSON.stringify({type:'File', fileName: file.name, fileSize: file.size});
		        log("============4===sending file, JSON string length: "+data.length);
		        peer.sendData(data);	
	      	}
	      	log("============4.1===e.target.result.byteLength: "+e.target.result.byteLength);

	      	var data_value_u8 = new Uint8Array(e.target.result);
	      	var data_value = Array.apply(null, data_value_u8);
	      	peer.sendData(e.target.result);

	        if (file.size > offset + e.target.result.byteLength) {
	          window.setTimeout(sliceFile, 0, offset + chunkSize);
	        }
	        sendProgress.value = offset + e.target.result.byteLength;
	      };
	    })(file);
	    var slice = file.slice(offset, offset + chunkSize);
	    reader.readAsArrayBuffer(slice);
	  };

	  sliceFile(0);
	  log("============5===Sending File, name: "+file.name);
	}
	/////////////////////////////////////////////////////
	///HTML control handlers
	function sendText() {
	  var data = sendTextarea.value;
	  
	  peer.sendData(JSON.stringify({type:  'Text', value: data}));
	  log("Sending Text: "+data);
	}

	/////////////////////////////////////////////////////
	// receive fill util functions and variables

	function OnFileData(fName, fSize, fileData, valueLength) {
	  log("========fSize:"+fSize+"============"+valueLength+"==============="+fileData.byteLength);
	  if (fileName === '' && fileSize === 0) {
	    // beginning of file transfering
	    fileName = fName;
	    fileSize = fSize;
	    receiveBuffer = [];
	    receivedSize  = 0;
	    receiveUint8Buffer = new Uint8Array(fSize);
	  }
	  // in progress of file transfering
	  if (fileName !== fName || fileSize !== fSize) {
	    log("Something wrong when transfering file, reason[file name/size does not match]");
	    log("Something wrong when transfering file, fileName:" + fileName + ", fileSize:" + fileSize + ", fName:"+fName + ", fSize:"+fSize);
	    fileName = '';
	    fileSize = 0;
	    receiveBuffer = [];
	    receivedSize  = 0;
	    receiveUint8Buffer = new Uint8Array(0);
	    return;  
	  }

	  receiveBuffer.push(fileData);
	  var fileDataUint8Buffer = new Uint8Array(fileData);
	  for (var i = 0; i < valueLength; ++i) {
	  	receiveUint8Buffer[receivedSize+i] = fileDataUint8Buffer[i];
	  }
	  receivedSize += valueLength;
	  
	  if (receivedSize === fileSize) {
	    log("File received, name:"+fileName + ", size:"+fileSize);
	    var received = new window.Blob(receiveBuffer);

	    downloadDiv.href = URL.createObjectURL(received);
	    downloadDiv.download = fileName;
	    var text = 'Click to download \'' + fileName + '\' (' + fileSize + ' bytes)';
	    downloadDiv.appendChild(document.createTextNode(text));
	    downloadDiv.style.display = 'block';

	    fs.open(dataPath+fileName+".png", 'w', function(err, fd) {
	    	if (err) {
	    		log("open file failed img.jep");
	    	} else {
	    		var a_buf = receiveUint8Buffer.buffer;
	    		var buf = new Buffer(receivedSize);

	    		for (var i = 0; i < receivedSize; ++i) {
	    			buf[i] = receiveUint8Buffer[i];
	    		}
	    		fs.write(fd, buf, 0, buf.length, function(err, written, buffer) {
	    			if (err) {
	    				log("====writen to file failed");
	    			} else {
	    				log("===========done written: "+written);
	    			}
	    		});
	    	}
	    });

	    // able to receive file from guest again
	    fileName = '';
	    fileSize = 0;
	  }
	}

	function log(text) {
	  console.log(text);
	  receiveTextarea.value += '..........event log: '+text + '\n';
	}
</script>

</body>
</html>